<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 引用
        // 分类:显示引用和隐式引用

        // 显示引用:一个对象访问另一个对象下属性
        // ---->一个对象引用另一个对象
        // 隐式引用:一个对象,通过原型对象访问的属性

        // 对象:GO AO 函数对象 普通对象

        // 引用计数垃圾收集
        // --->关键看,一个对象是否被其他变量所引用(使用)
        // 零引用对象:被垃圾回收机制所回收

        var o = {
            a: {
                b: 2,
            },
        };
        // 两个对象,一个key为a 一个key为b
        //两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
        //很显然，没有一个可以被垃圾收集

        var o2 = o; // o2 引用key为a的对象
        o = 1 // o // 这个时候 只有o2引用key为a的对象;o不再引用了
        var oa = o2.a; // key 为b的对象被oa变量和a属性引用
        o2 = 'yo'; //虽然最初的对象现在已经是零引用了，可以被垃圾回收了
                   //但是它的属性a的对象还在被oa引用，所以还不能回收
        oa = null; //a属性的那个对象现在也是零引用 它可以被垃圾回收了

        // 总结:代码从头执行到尾部,如果说这个对象以及对象中属性,没有被任何全局变量所引用(直接,间接)那么这个对象就会被回收

        // 循环引用:(学术观点不同),浏览器底层处理方式不同 ie 6,7 内存泄漏(符合引用技术垃圾算法),其他浏览器,可能用的是循环引用算法和引用计算垃圾算法
        
    </script>
</body>

</html>